/*
*	Мультипликативный линейный конгруэнтный генератор с простым модулем:
*			Z[i] = (A * Z[i - 1] + C) (mod M), где
*	A = 630360016
*	C = 0
*	M = 2^31 - 1 (2147483647)
*/

#ifndef ___RAND_H___
#	define ___RAND_H___
#	include <stdint.h>

#	define FIRST16	65535			/* 2^16 - 1*/
#	define FIRST15	32767			/* 2^15 - 1*/
#	define M	2147483647		/* 2^31 - 1 */

/* A = MUL1 * MUL2 */
#	define MUL1	24112
#	define MUL2	26143

#	define INV_RAND_MAX 4.656612875e-10	/* 1 / (2^31 - 1) */

static int32_t zrng[] =
{
	1,
	1973272912,	281629770,	20006270,	1280689831,	2096730329,	1933576050,
	913566091,	246780520,	1363774876,	604901985,	1511192140,	1259851944,
	824064364,	150493284,	242708531,	75253171,	1964472944,	1202299975,
	233217322,	1911216000,	726370533,	403498145,	993232223,	103205531,
	762430696,	1922803170,	1385516923,	76271663,	413682397,	726466604,
	336157058,	432650381,	1120463904,	595778810,	877722890,	1046574445,
	68911991,	2088367019,	748545416,	622401386,	2122378830,	640690903,
	1774806513,	2132545692,	2079249579,	78130110,	852776735,	1187867272,
	1351423507,	1645973084,	1997049139,	922510944,	2045512870,	898585771,
	243649545,	1004818771,	773686062,	403188473,	372279877,	1901633463,
	498067494,	2087759558,	493157915,	597104727,	1530940798,	1814496276,
	536444882,	1663153658,	855503735,	67784357,	1432404475,	619691088,
	119025595,	880802310,	176192644,	1116780070,	277854671,	1366580350,
	1142483975,	2026948561,	1053920743,	786262391,	1792203830,	1494667770,
	1923011392,	1433700034,	1244184613,	1147297105,	539712780,	1545929719,
	190641742,	1645390429,	264907697,	620389253,	1502074852,	927711160,
	364849192,	2049576050,	638580085,	547070247
};

static int32_t prev_z = 281629770;

static inline void smrand(unsigned int seed)
{
	prev_z = zrng[seed % sizeof(zrng)];
}

static int32_t mrand()
{
	int32_t low16, high15;
	
	/*Z[i - 1] * MUL1 = high15 * MUL1 + low16 * MUL1 */
	
	/* Умножение первых 16-бит Z[i - 1] на MUL1 */
	low16 = (prev_z & FIRST16) * MUL1;

	/* Умножение старших (не считая знакового бита) 15-бит 
	*  на MUL1 и прибавление той части low16, которая
	*  выходит за границы первых 16-бит 
	*/
	high15 = (prev_z >> 16) * MUL1 + (low16 >> 16);

	/* Циклический сдвиг налево на 16-бит hig15,
	*  прибавление первых 16-ти бит log16 и
	*  вычитание модуля M
	*/
	prev_z = ( (high15 & FIRST15) << 16 ) + (high15 >> 15) + (low16 & FIRST16) - M;
	
	/* Если значение prev_z не выходило за границы M, 
	*  то вернуть это значение назад
	*/
	if (prev_z < 0) prev_z += M;

	/* Тоже самое, но для MUL2 */
	/*Z[i - 1] * MUL2 = high15 * MUL2 + low16 * MUL2 */
	low16 = (prev_z & FIRST16) * MUL2;
	high15 = (prev_z >> 16) * MUL2 + (low16 >> 16);
	prev_z = ( (high15 & FIRST15) << 16 ) + (high15 >> 15) + (low16 & FIRST16) - M;
	if (prev_z < 0) prev_z += M;

	return  prev_z;
}

#endif // ___RAND_H___